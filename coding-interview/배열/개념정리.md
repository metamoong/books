# 해시 테이블

- 효율적인 탐색을 위한 자료구조로 키를 값에 대응시킴
- 연결리스트와 해시코드 함수를 이용해 간단한 해시테이블 구현 가능

### ☑️ 키와 값을 해시테이블에 넣는 과정

1. 키의 해시 코드 계산 (주로 int나 long 자료형이 됨)

   서로 다른 두 개의 해시 코드가 같은 인덱스를 가리킬 수 있음

2. hash(key)%array_length 와 같은 방식으로 해시 코드를 이용해 배열의 인덱스를 구함

3. 배열의 각 인덱스에는 키와 값으로 이루어진 연결리스트 존재. 키와 값을 해당 인덱스에 저장. 서로 다른 두 개의 키가 같은 해시 코드를 가리키거나 서로 다른 두 개의 해시코드가 같은 인덱스를 가리킬 수 있으므로 이를 대비해 연결리스트를 사용해야함

### ☑️ 해시테이블에서 키에 상응하는 값을 찾는 과정

1. 주어진 키로부터 해시 코드 계산
2. 해시 코드를 이용해 인덱스 계산
3. 해당 키에 상응하는 값을 연결리스트에서 탐색 → 최악의 경우 수행시간 O(N), 잘 구현된 해시테이블의 경우 탐색시간 O(1)

### ☑️ 다른 구현 방법

균형 이진 탐색 트리를 사용해 구현할 수도 있음 → 탐색 시간 O(logN)

- 크기가 큰 배열을 미리 할당해 놓지 않아도 됨
- 키의 집합을 특정 순서로 차례대로 접근 가능

## ArrayList와 가변 크기 배열

- 특정 언어에서는 배열의 크기를 자동으로 조절 가능 (데이터를 덧붙일 때마다 배열 혹은 리스트의 크기 증가)
- 자바 같은 언어에서는 배열의 길이가 고정되어 있어 배열을 만들 때 크기를 함께 지정해야 함
  ```java
  int[] intArray = new int[5];
  ```
- 동적 가변 크기 기능이 내재되어 있는 배열과 비슷한 자료구조를 원할 때는 보통 ArrayList 사용
  → 필요에 따라 크기를 변화시킬 수 있으면서, O(1)의 접근 시간을 유지함
  → 배열이 가득 차면 배열의 크기를 2배로 늘리는데, 이는 자주 발생하지 않으므로 상환 입력 시간으로 계산 시 O(1)이 됨
    <aside>
    💡 상환 입력 시간이 O(1)이 되는 이유
    
    마지막 배열 크기 증가 : n/2개의 원소를 복사
    이전 배열 크기 증가 : n/4개의 원소를 복사
    …
    첫 번째 배열 크기 증가 : 1개의 원소를 복사 
    
    → N개의 원소를 삽입하기 위해 복사해야 하는 원소의 총 개수 = N/2 + N/4 + … +1 < N
    → 평균적으로 각 삽입은 O(1) 이 소요됨
    
    </aside>

### ☑️ StringBuilder

- 문자열의 리스트가 주어졌을 때 이 문자열들을 하나로 이어 붙일 때의 수행시간은?
  → 두 개의 문자열을 읽어 들인 뒤 문자를 하나하나 새로운 문자열에 복사해야 함
  → 문자열의 길이를 x라 하면, O(x+2x+…+nx) = O(xn^2) (1+2+…+n = n(n+1)/2)
- StringBuilder을 사용하면 수행시간을 줄일 수 있음
  ```java
  String joinWords(String[] words){
  	StringBuilder sentence = new StringBuilder();
  	for(String w:words){
  		sentence.append(w);
  	}
  	return sentence.toString();
  }
  ```
  → StringBuilder는 단순하게 가변 크기 배열을 이용해 필요한 경우에만 문자열을 복사하게끔 해줌
  → 클래스 내부에 배열 공간을 만들어두고, `append` 메서드를 사용해 만들어 둔 배열에 문자열이 바로 추가되는 방식, 공간이 부족해지면 공간을 늘리고 문자열 복사
